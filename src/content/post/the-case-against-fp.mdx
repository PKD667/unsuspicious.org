---
title: 'The case against functional programming'
tags: ['engineering', 'design patterns', 'programming']
author: 'pkd'
excerpt: 'Mathematical thinking with code, a C-loving mathcel\'s perspective.'
date: '2024-12-30'
---

# Why not Haskell ?

Following twitter trends, I have always found the *idea* of functional programming attractive : when working with low-level systems, which were my primary area of expertise for a long time, you don't really have the choice of using anything else than C, and it's shortcomings become very oppresive after some time. Thinking like a machine can feel very dehumanizing, and debugging it is the most tedious task you could think of. When more recently I changed my focus on more math-directed problems, I naturally thought that Haskell (or OCaml if I wanted to stay French) would be the perfect tool for the job. 

After hapily spending a few nights on category theory lectures, I started writting code to solve some exercises I had given myself. It seemed like a huge relief, finally something that requires more *thinking* than suffering. This effect lasted on me for a few days, and for it's credit, it was stronger than just the usual "new language" excitement. It allowed me to implement some proofs, write elegant stuff and feel like I was doing something meaningful.

# How to think like a machine

Category theory lectures always start with a long rambling about how **FP** was a revolution in the way we think programming, and more generally a way to free ourselves from the *machine paradigm* imposed by the educational system. As someone who actually struggled a lot with math in school, and was very revulsed by the way it was taught, in a very mechanical way, I find this argument very compelling. "Elevating the machines to our level" is poetic, and a very nice way to think about it. 

Just a few days later, I had a new project involving RF processing thus obviously fourrier transforms, and it seems like the best time to put to the test my new *functionnal skills* in a real-world problem. In order to warm up a bit, I started by implementing a very naive, simple fourrier transform (far from the FFT) in Haskell. My goal was to get an algoithmic approximation over some waves, and then compare it to actual data. After a few minutes, i realized that I **couldn't** do it using the pure *mathy* way I had learned. Indeed, the goal was to get a *brute* aproximmation, based on sequen